# homework5

Требуется написать несколько методов, которые будут проводить основные операции с базой и чуть-чуть логики добавить с обработкой ошибок.

Большая часть того что будет писаться вами в реальной жизни будет похоже на это, так что если вы хорошо разберетесь в данном задании - считайте что дальше у вас все будет получаться.

Данное задание предполагает что у вас установлен postgres и примеры из лекции корректно запускаются.

Вам будет необходимо написать следующие методы в виде хттп-хендлеров (net/http, не echo):
* List - получает список сообщений пользователя; работает через метод GET
* Create - создает новою запись в базе. Не совсем похоже на отправку письма, но INSERT-ы както надо отрабатывать без успер-усложненной логики; работает через метод PUT.
* Mark - помечает письмо (не)прочитанным или флажком, или и то, и другое; работает через метод POST
* Delete - удаляет письмо; работает через метод DELETE

У вас есть 2 таблицы - sessions и messages.
Вы можете посмотреть изх вместе с тестовыми данными в конфе файла crud_test.go, в переменной dbDump

В таблицк sessions хранятся сессии ( заранее заготовыленные, кода для добавления не нужно), в messages - письма.
Сессионный ключ берем из куки, идем с ним в базу, оттуда вытаскиваем user_id, с ним уже идем во вторую таблицу.
Не забудьте обрабатывать ситуацию когда сессия не найдена, а так же когда письмо, которое вы хотите удалть-изменить принадлежит другому пользователю. В этом случае необходимо будет отдать 404 статус ответа, так же как в случае если такого письмо вообще нету.

Для проверки сессии и метода запроса удобно написать в виде отдельного метода, который будет вызываться во всех ваших http-хендлерах.

В целом в этом задании очень много надо будет смотреть в тесты - что приходит в ваш код и что ожидается в ответе.

Общая стратегия решения:
1. смотрим какие данные уходят на сервер
2. смотрим на что запрос - на ошибку ( наприме валидацию входных параметров данных ) или успешный
3. если на валидацию - пишем код для валидации, чтобы этот тест-кейс отрабатывал успешно
4. если успешный запрос - смотрим что мы хортим отправить в базу, обычно там будет одно из select-update-insert-delete
5. повторяет для каждого тест-кейса

Все ответы со стороны сервера - JSON-формате ( см ApiGetItems ). Никакого html.
Проще всего использовать для формирования ответов map[string]interface{}, но можно и структурами, особенно если вы захотите использовать sqlx. 
Только помните про то что публичные поля должны называться с большой буквы и для корректного регистра имен полей они должны иметь теги в структуре (см 4_http/14_json/struct_tags.go).

Можно использовать sqlx, но для этого вам необходимо будет самим его инициализирвать в NewMessager. Эталонное решение написано без него.

Чисто технчиески - все решение можно накопипастить из лекций в более-менее минимальными правками. Но я рекоменуд вдумчиво писать, понимая что вы делаете.

* Для поля priority надо будет заменить число на строку ( испольщзуйте мапу )
* Для поля read надо будет заменить число на булевую переменную ( испольщзуйте мапу )
* В методе может быть несколько sql-запросов в базу, не обязательно 1.
* Все создание таблиц при каждом тесте происходит автоматически, с удалением того что там было ранее.
* Глобальные переменные использовать нельзя. Кроме коннекта к базе вам ничего хранить не требуется, все в базе.
* Не забывайте закрывать коннекты ( rows.Close ), это будет везде проверяться. 
* То что в тестах CR - это map[string]interface{} - я просто определирл такой тип чтобы не писать мапу руками каждый раз
* при insert вы можете указать все вставляемые поля и тогда id не нужен, а если не указываете - вам надо передать в значениях все поля и в id надо писать DEFAULT

* Если письмо у вас будут отдаваться не в том порядке - добавьте `ORDER BY id ASC` в конец вашего запроса на SELECT ( без кавычек )

* Конфиг коннекта к базе можно поменять в файле cfg.go - только меняйте переменную, не надо ее никуда переносить. Так сделано для того чтобы на сервере было конфиг, который вы не меняете.
* Весь код пишите в файле crud.go, его же грузить на сервер
* Запускать тесты через go test -v 
* Эталонное решение у меня заняло 250 строк кода
